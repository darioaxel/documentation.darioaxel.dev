# Creación de un sistema de DHCP con VirtualBox'

Ejercicio de configuración de un sistema de DHCP en VirtualBox donde el servidor se cuentra instalado en una red y a través de un router, entrega direcciones a clientes de otras redes

# Bitácora
- [x] Interfaces de router y máquinas en VirtualBox
- [x] Modificación de hostnames en máquinas
  - [x]   Router
  - [x]   DHCPServer
  - [x]   Client1
  - [x]   Client2
- [x] Habilitar en el router **ip forward**
- [ ] **Nftables** para las redes en el router

# Esquema de la Red
  | |  |  | 
  | --- | --- | --- |   
  | **Router** | red NAT | |  
  |  | red 1 | 10.1.0.254 |  
  |  | red 2 | 10.2.0.254|  
  | **DHCPServer** | red 1 | 10.1.0.1| 
  | **Client1** | red 2 | 10.2.0.1 |  
  | **Client2** | red 2 | 10.2.0.2 | 


# 1. Creación de las distintas máquinas mediante clonado 
Para este ejercicio se utilizan 4 máquinas *Debian 11* creadas a partir de una instancia base (1Gb RAM, 1 Core, 2Gb disco). Hemos de tener cuidado en el clonado de renovar las MAC de los adaptadores de red que tengamos, en caso contrario tendremos problemas a la hora de configurar las redes por conflictos entre ellos.

# 2. Modificación de los identificadores de las máquinas para su uso en la red
Además de las direcciones MAC, hemos de preveer el uso de las distintas máquinas y su acceso, por lo que será conveniente modificar el **hostname** que tienen y evitar repeticiones dentro de las redes.

Los dos archivos a parametrizar son:

```shell
/etc/hostname
/etc/hosts
``` 
Podemos comprobar el estado inicial del **hostname** tal y como se puede ver en la siguiente captura de pantalla:  
![hostname](./hostname-1.png "resultado de comando hostname")

O comprobarlo usando **hostnamectl**, que nos muestra más información:
![hostnamectl](./hotsnamectl.png "resultado de comando hostnamectl")

Para modificar el **hostname** podemos lanzar el comando **hostnamectl** tal y como se muestra en la siguiente imagen:

![hostnamectl](./hostnamectl-3.png "resultado de comando hostnamectl")

Utilizaremos un editor de texto como, por ejemplo, **nano** para cambiar los datos necesarios en **hosts**
```shell
sudo nano /etc/hosts
``` 

![hostnamectl](./hostname-hosts.png "resultado de comando hostnamectl")

Una vez configurados los nombres de las máquinas, debemos establecer las direcciones IP para cada una de ellas en el archivo:

```shell
sudo nano /etc/network/intefaces
```
Por defecto únicamente tendremos la intefaz definida como *auto* para su configuración mediante **DHCP**. Deberemos parametrizar cada una de las nuevas interfaces implementadas al crear nuestra máquina virtual añadiendo un bloque de configuración como el siguiente, para cada una:

```shell
iface enp0sX inet static
address  XXX
gateway  XXX
```


# 3. Configuración de la máquina servidor para trabajar como router

Como primer paso se ha de habilitar el servidor descomentamos, modificamos o añadimos la siguiente linea en */etc/sysctl.conf*
```shell
net.ipv4.ip_forward=1
```
Posteriormente debemos comprobar que todas las interfaces de red están activas, y por tanto puede trabajar como router, en la máquina. Comprobamos el fichero:

```shell
  /etc/network/interfaces  
```

## Filtrado de direcciones IP

Una vez hecho esto y habilitado el reenvio de paquetes IP, es necesario conocer si nuestra versión de Linux utiliza **nftables** o **iptables** para gestionar las entradas y salidas de paquetes IP. 

**NFTABLES** es la evolución hacia el filtrado de paquetes que hasta ahora representaba iptables.

* Está disponible desde kernels Linux 3.13  
* Tiene una nueva interfaz de comando cuya sintaxis es diferente de iptables  
* Proporciona una nueva infraestructura que permite construir mapas y concatenaciones.  
* Esta nueva característica le permite organizar un conjunto de reglas en un árbol multidimensional, lo que reduce la cantidad de reglas que deben consultarse drásticamente hasta encontrar la acción que se aplica en el paquete.

##### ¿Por qué usar NFTABLES?
* Evita la duplicación de código y las inconsistencias.
* Ordene los paquetes más rápido con un conjunto de mapeo de datos mejorado
* Simplifica la administración de ipv4 e ipv6 con una nueva familia, inet, que le permite registrar cadenas que pueden ver el tráfico ipv4 e ipv6
* Proporciona una API de Netlink para aplicaciones de terceros.
* Proporciona una sintaxis más amigable y compacta
##### ¿Cómo saber qué servicio esta usando nuestra máquina?   
Podemos buscar el status de ambos servicios para comprobar cuál es el que se encuentra activo. Los comandos serían:

```shell
// para iptables
systemctl status iptables
// o para nftables
systemctl status nftables
```

## 3.1. Configuración de **nftables**

##### Creación de la tabla
Vamos a crear una tabla para filtrar los paquetes que llamaremos filter:
```shell
# nft add table inet filter
```

Tenemos varias familias para crear las tablas, en nuestro caso hemos escogido inet que nos permite trabajar con ipv4 y ipv6.

Para ver la tabla que hemos creado:
```shell
#nft list tables
table inet filter
```
Puedes leer sobre más operaciones sobre las tablas [Aquí](https://wiki.nftables.org/wiki-nftables/index.php/Configuring_tables)

El arranque toma por defecto la configuración establecida en el fichero ***/etc/nftables.conf***
```shell
root@nft-fw:~# cat /etc/nftables.conf
```
```shell
#!/usr/sbin/nft -f

flush ruleset

table inet filter {
  chain input {
  type filter hook input priority 0;
}

chain forward {
  type filter hook forward priority 0;
}

chain output {
  type filter hook output priority 0;
}

```
#####  Creación de las cadenasPermalink
A continuación vamos a crear las cadenas de la tabla filter. Para crear una cadena debemos indicar varios parámetros:

* **type**: Es la clase de cadena que vamos a crear, por ejemplo filter (para filtrar) o nat (para hacer NAT).
* **hook**: Determina el tipo de paquete que se va a analizar. Por ejemplo:
  * **input**: Paquetes que tienen como destino la misma máquina.
  * **output**: Paquetes que tienen origen la propia máquina.
  * **forward**: Paquetes que pasan por la máquina.
  * **prerounting**: Paquetes que entran en la máquina antes de enrutarlos. Nos permiten hacer DNAT.
  * **postrouting**: Paquetes que están a punto de salir de la máquina. Nos permite hacer SNAT.
* **priority**: Nos permite ordenar las cadenas dentro de una misma tabla. Las cadenas más prioritarias son las que tienen un número más pequeño.
* **policy**: Se indica la política por defecto. Si el conjunto de reglas evaluadas no se ajusta al paquete se ejecuta la política por defecto. Por defecto la política es accept por lo que se aceptan todos los paquetes que no se ajusten al conjunto de reglas. Cuando desarrollamos un cortafuegos la política suele ser drop no aceptando los paquetes que no se ajustan a ninguna regla.

En la tabla filter que hemos creado anteriormente vamos a crear dos cadenas para nuestro cortafuego personal:
```shell
nft add chain inet filter input { type filter hook input priority 0 \
; counter \
; policy accept \
; }  

nft add chain inet filter output { type filter hook output priority 0 \; counter \; policy accept \; }
```
Por ejemplo para cambiar la política por defecto a drop de las cadenas creadas:
```shell
# nft chain inet filter input { policy drop \; }  
# nft chain inet filter output { policy drop \; }
```
Puedes leer la wiki para ver más operaciones sobre cadenas.

Finalmente ya hemos configurado nuestra tabla para filtrar paquetes y las cadenas que vamos a utilizar:
```shell
# nft list chains
table inet filter {
	chain input {
		type filter hook input priority 0; policy drop;
	}
	chain output {
		type filter hook output priority 0; policy drop;
	}
}
```


## 3.2. Configuración de IPTables


By default, these commands affect the filters table. If you need to specify a different table, use the –t option, followed by the name of the table.

Check Current iptables Status
To view the current set of rules on your server, enter the following in the terminal window:

sudo iptables -L

The system displays the status of your chains. The output will list three chains:

Chain INPUT (policy ACCEPT)

Chain FORWARD (policy ACCEPT)

Chain OUTPUT (policy ACCEPT)

Enable Loopback Traffic
It’s safe to allow traffic from your own system (the localhost). Append the Input chain by entering the following:

sudo iptables -A INPUT -i lo -j ACCEPT

This command configures the firewall to accept traffic for the localhost (lo) interface (-i). Now anything originating from your system will pass through your firewall. You need to set this rule to allow applications to talk to the localhost interface.

Allow Traffic on Specific Ports
These rules allow traffic on different ports you specify using the commands listed below. A port is a communication endpoint specified for a specific type of data.

To allow HTTP web traffic, enter the following command:

sudo iptables -A INPUT -p tcp --dport 80 -j ACCEPT

To allow only incoming SSH (Secure Shell) traffic, enter the following:

sudo iptables -A INPUT -p tcp --dport 22 -j ACCEPT

To allow HTTPS internet traffic, enter the following command:

sudo iptables -A INPUT -p tcp --dport 443 -j ACCEPT

The options work as follows:

-p – Check for the specified protocol (tcp).
--dport – Specify the destination port.
-j jump – Take the specified action.
Control Traffic by IP Address
Use the following command to ACCEPT traffic from a specific IP address.

sudo iptables -A INPUT -s 192.168.0.27 -j ACCEPT

Replace the IP address in the command with the IP address you want to allow.

You can also DROP traffic from an IP address:

sudo iptables -A INPUT -s 192.168.0.27 -j DROP

You can REJECT traffic from a range of IP addresses, but the command is more complex:

sudo iptables -A INPUT -m iprange --src-range 192.168.0.1-192.168.0.255 -j REJECT

The iptables options we used in the examples work as follows:

-m – Match the specified option.
-iprange – Tell the system to expect a range of IP addresses instead of a single one.
--src-range – Identifies the range of IP addresses.
Dropping Unwanted Traffic
If you define dport iptables firewall rules, you need to prevent unauthorized access by dropping any traffic that comes via other ports:

sudo iptables -A INPUT -j DROP

The -A option appends a new rule to the chain. If any connection comes through ports other than those you defined, it will be dropped.

Delete a Rule
You can use the -F option to clear all iptables firewall rules. A more precise method is to delete the line number of a rule.

First, list all rules by entering the following:

sudo iptables -L --line-numbers

Locate the line of the firewall rule you want to delete and run this command:

sudo iptables -D INPUT <Number>

Replace <Number> with the actual rule line number you want to remove.

Save Your Changes
Iptables does not keep the rules you created when the system reboots. Whenever you configure iptables in Linux, all the changes you make apply only until the first restart.

To save the rules in Debian-based systems, enter:

sudo /sbin/iptables–save

To save the rules in Red-Hat based systems, enter:

sudo /sbin/service iptables save

The next time your system starts, iptables will automatically reload the firewall rules.
# 4. Instalación y configuración del servicio DHCP
## 4.1. DHCP con isc-dhcp-server
## 4.2. Uso de Kira como servidor DHCP
